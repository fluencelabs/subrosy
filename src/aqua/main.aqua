import "@fluencelabs/registry/resources-api.aqua"
import "@fluencelabs/registry/registry-service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "@fluencelabs/aqua-ipfs/ipfs-api.aqua"
import "utils.aqua"
import "ipfs.aqua"
import "healthcheck_service.aqua"

alias Error: string
alias CID: string
alias Multiaddr: string

service Console("run-console"):
    print(msgs: []string)

func find_blueprint(name: string) -> ?Blueprint:
    result: *Blueprint
    bps = Dist.list_blueprints()
    for bp <- bps:
      if bp.name == name:
        result <<- bp
    <- result

func find_service(blueprint_id: string) -> ?Service:
    result: *Service
    services = Srv.list()
    for serv <- services:
      if serv.blueprint_id == blueprint_id:
        result <<- serv
    <- result

func deploy(bid: string, tag: string, subnet: string) -> bool, *Error:
    sid <- Srv.create(bid)
    success, errors <- registerServiceRecord(subnet, tag, INIT_PEER_ID, [sid])
    <- success, errors
    

func deploy_storage(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", STORAGE, subnet)
    <- success, errors
    

func deploy_healthcheck_service(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", SERVICE, subnet)
    <- success, errors


func upload_air(air_path: string, ipfs_host: PeerId) -> ?CID, ?Error:
    error: ?Error
    cid: ?CID

    Console.print(["will upload", air_path, ipfs_host])

    maddr <- get_external_api_multiaddr(ipfs_host)
    if maddr.success:
        Console.print(["success", maddr.multiaddr])
        cid <- upload(maddr.multiaddr, air_path)
    else:
        Console.print(["fail", maddr.error])
        error <<- maddr.error

    <- cid, error

func register_healthcheck(subnet: string, air_cid: string, ipfs_host: PeerId) -> ?ResourceId, ?[]Error:
    error: ?[]Error

    id, error_cre <- createResource(subnet)

    if id != nil:
        registered, error_reg <- registerServiceRecord(id!, IPFS_HEALTHCHECK_SCRIPT, ipfs_host, ?[air_cid])
        if registered == false:
            error <<- error_reg
    else:
        error <<- error_cre

    <- id, error

func create_healthcheck(subnet: string, air_path: string, ipfs_host: PeerId) -> ?CID, ??ResourceId, ?[]Error:
    error: ?[]Error
    id: ??ResourceId

    cid, upload_err <- upload_air(air_path, ipfs_host)

    Console.print(cid)

    if cid != nil:
        id, reg_err <- register_healthcheck(subnet, cid!, ipfs_host)
        if reg_err != nil:
            error <<- reg_err!
    else:
        error <<- ["upload_air", ipfs_host, air_path, upload_err!]

    <- cid, id, error


func install_healthcheck_scripts(subnet: string, target_host: PeerId) -> [][]Error:
    errors: *[]Error
    installed_cids: *string

    id, error_cre <- createResource(subnet)

    if id != nil:
        records, error_resolve <- resolveResource(id!, 3) -- '3' acks
        if records != nil:
            for r <- records!:
                if r.metadata.value == IPFS_HEALTHCHECK_SCRIPT:
                    cid = r.metadata.service_id!
                    if contains(installed_cids, cid): -- if we hadn't install this cid yet, go install it
                        maddr <- get_external_api_multiaddr(r.metadata.peer_id)
                        if maddr.success:
                            get <- get_from(target_host, cid, maddr.multiaddr)
                            if get.success:
                                on target_host:
                                    Script.add_from_vault(get.path, ?[10])
                            else:
                                errors <<- ?["ipfs.get", cid, get.error]
                        else:
                            errors <<- ?["get_external_api_multiaddr", r.metadata.peer_id, maddr.error]
        else:
            errors <<- error_resolve
    else:
        errors <<- error_cre

    <- errors

service UCompare("cmp"):
    gt(x: u32, y: u32) -> bool

func enable_healthcheck(subnet: string):
    records, error <- get_records(subnet, 5)
    scripts <- find_records(records!, IPFS_HEALTHCHECK_SCRIPT)
    rec = scripts[0]
    install_healthcheck_scripts(subnet, rec.metadata.peer_id)

    service_records <- find_records(records!, SERVICE)
    -- is it correct to get the first one?
    service_record = service_records[0]

    deploy_healthcheck_service(HOST_PEER_ID)

    storage_records <- find_records(records!, STORAGE)

    good_amount <- UCompare.gt(storage_records.length, service_records.length / 3)

    if good_amount == false:
        -- TODO: how many storages to deploy
        -- TODO: where to deploy
        deploy_storage(subnet)
    -- TODO: check if there is enough HealthCheckStorage services
    --       if not, deploy one

func register_service(subnet: string, host: PeerId, service_id: string) -> [][]Error:
    errors: *[]Error

    id, error_cre <- createResource(subnet)

    if id != nil:
        registered, error_reg <- registerServiceRecord(id!, SERVICE, host, ?[service_id])
        if registered:
            enable_healthcheck(subnet)
        else:
            errors <<- error_reg
    else:
        errors <<- error_cre

    <- errors

func get_health(subnet: string) -> []HealthStatus:
    statuses: *HealthStatus

    id, error_cre <- createResource(subnet)

    if id != nil:
        records, error_resolve <- get_records(subnet, 3) -- '3' acks

    healthchek_storage_services <- find_records(records!, STORAGE)
    services <- find_records(records!, SERVICE)
    for storage <- healthchek_storage_services par:
        for srv <- services par:
            on storage.metadata.peer_id:
                HealthCheckStorage storage.metadata.service_id!
                statuses <- HealthCheckStorage.get_status(srv.metadata.service_id!)

    <- statuses
