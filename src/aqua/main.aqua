import "@fluencelabs/registry/resources-api.aqua"
import "@fluencelabs/registry/registry-service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "@fluencelabs/aqua-ipfs/ipfs-api.aqua"
import "@fluencelabs/aqua-ipfs/ipfs.aqua"
import "utils.aqua"
import "ipfs.aqua"
import "healthcheck_service.aqua"

alias Error: string
alias CID: string
alias Multiaddr: string

service Console("run-console"):
    print(msgs: []string)

func find_blueprint(name: string) -> ?Blueprint:
    result: *Blueprint
    bps = Dist.list_blueprints()
    for bp <- bps:
      if bp.name == name:
        result <<- bp
    <- result

func find_service(blueprint_id: string) -> ?Service:
    result: *Service
    services = Srv.list()
    for serv <- services:
      if serv.blueprint_id == blueprint_id:
        result <<- serv
    <- result

func deploy(bid: string, tag: string, subnet: string) -> bool, *Error:
    sid <- Srv.create(bid)
    success, errors <- registerServiceRecord(subnet, tag, INIT_PEER_ID, [sid])
    <- success, errors


func deploy_storage(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", STORAGE, subnet)
    <- success, errors


func deploy_healthcheck_service(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", SERVICE, subnet)
    <- success, errors


func upload_air(air_path: string, ipfs_host: PeerId) -> ?CID, ?Error:
    error: ?Error
    cid: ?CID

    Console.print(["will upload", air_path, ipfs_host])

    maddr <- get_external_api_multiaddr(ipfs_host)
    if maddr.success:
        Console.print(["success", maddr.multiaddr])
        cid <- upload(maddr.multiaddr, air_path)
    else:
        Console.print(["fail", maddr.error])
        error <<- maddr.error

    <- cid, error

func create_healthcheck(subnet: ResourceId, air_path: string, ipfs_host: PeerId) -> ?CID, ?[]Error:
    errors: ?[]Error

    cid, upload_err <- upload_air(air_path, ipfs_host)

    Console.print(cid)

    if cid != nil:
        registered, err_reg <- registerServiceRecord(subnet, IPFS_HEALTHCHECK_SCRIPT, ipfs_host, ?[cid!])
        if err_reg != nil:
            errors <<- err_reg
    else:
        errors <<- ["upload_air", ipfs_host, air_path, upload_err!]

    <- cid, errors

service IOp("op"):
    identity(i: u32) -> u32

func create_subnet(subnet_label: string, air_path: string, ipfs_hosts: []PeerId) -> ?ResourceId, u32, []Error:
    errors: *Error
    uploaded: *bool

    subnet, errors_cre <- createResource(subnet_label)

    if subnet != nil:
        for ipfs <- ipfs_hosts par:
            cid, errors_hc <- create_healthcheck(subnet!, air_path, ipfs)
            uploaded <<- true
            if errors_hc != nil:
                for e <- errors_hc!:
                    errors <<- e

            l = IOp.identity(ipfs_hosts.length)
            join uploaded[l]
            par Peer.timeout(PARTICLE_TTL * 8 / 10, "")

    else:
        for e <- errors_cre:
            errors <<- e

    uploaded_can = uploaded
    uploaded_len = IOp.identity(uploaded_can.length)

    <- subnet, uploaded_len, errors

-- Register deployed HealthStorage service to subnet
func register_storage(subnet: ResourceId, storage_id: string, host: PeerId):
    registered, err_reg <- registerServiceRecord(subnet, STORAGE, host, ?[storage_id])


-- Install subnet's healthcheck scripts as scheduled scripts to `target_host` peer
func install_healthcheck_scripts(scripts: []Record, target_host: PeerId) -> []string, [][]Error:
    errors: *[]Error
    installed_cids: *string
    installed_scripts: *string
    maddrs: *IpfsMultiaddrResult

    for r <- scripts:
        if r.metadata.value == IPFS_HEALTHCHECK_SCRIPT:
            cid = r.metadata.service_id!
            if contains(installed_cids, cid) == false: -- if we hadn't install this cid yet, go install it
                maddr <- get_external_api_multiaddr(r.metadata.peer_id)
                maddrs <<- maddr
                if maddr.success:
                    get <- get_from(target_host, cid, maddr.multiaddr)
                    if get.success:
                        on target_host:
                            installed_scripts <- Script.add_from_vault(get.path, ?[10])
                        installed_cids <<- cid
                    else:
                        errors <<- ?["ipfs.get", cid, get.error]
                else:
                    errors <<- ?["get_external_api_multiaddr", r.metadata.peer_id, maddr.error]

    <- installed_scripts, errors

-- It's the key owner's job to make sure that there are enough HealthStorage services
-- maybe there are NO storage services? it's all hidden inside the healthcheck script anyway

func enable_healthcheck(subnet: string, host: PeerId) -> [][]Error:
    errors: *[]Error

    records, error <- get_records(subnet, 5)

    if records != nil:
        if contains_peer_id(records!, host) == false:
            scripts <- find_records(records!, IPFS_HEALTHCHECK_SCRIPT)
            installed_scripts, install_errs <- install_healthcheck_scripts(scripts, host)
            for err <- install_errs:
                errors <<- err
    else:
        errors <<- error

    <- errors

func join_subnet(subnet: ResourceId, host: PeerId, service_id: string) -> []Error:
    errors: *[]Error

    registered, error_reg <- registerServiceRecord(subnet, SERVICE, host, ?[service_id])
    -- TODO: check that service wasn't registered yet?
    if registered:
        enable_healthcheck(subnet, host)

    <- error_reg

func get_health(subnet: string) -> []HealthStatus:
    statuses: *HealthStatus

    id, error_cre <- createResource(subnet)

    if id != nil:
        records, error_resolve <- get_records(subnet, 3) -- '3' acks

    storages <- find_records(records!, STORAGE)
    services <- find_records(records!, SERVICE)
    for storage <- storages par:
        for srv <- services par:
            on storage.metadata.peer_id via storage.metadata.relay_id:
                HealthCheckStorage storage.metadata.service_id!
                statuses <- HealthCheckStorage.get_status(srv.metadata.service_id!)

    <- statuses
