import "@fluencelabs/registry/resources-api.aqua"
import "@fluencelabs/registry/registry-service.aqua"
import "@fluencelabs/aqua-lib/builtin.aqua"
import "@fluencelabs/aqua-ipfs/ipfs-api.aqua"
import "@fluencelabs/aqua-ipfs/ipfs.aqua"
import "utils.aqua"
import "ipfs.aqua"
import "healthcheck_service.aqua"

alias Error: string
alias CID: string
alias Multiaddr: string

service HOp("op"):
    array_length(hss: []HealthStatus) -> u32

service ROp("op"):
    array_length(hss: []Record) -> u32

service RConsole("run-console"):
    print(r: Record)

service Console("run-console"):
    print(msgs: []string)

service NConsole("run-console"):
    print(n: u32)

func find_blueprint(name: string) -> ?Blueprint:
    result: *Blueprint
    bps = Dist.list_blueprints()
    for bp <- bps:
      if bp.name == name:
        result <<- bp
    <- result

func find_service(blueprint_id: string) -> ?Service:
    result: *Service
    services = Srv.list()
    for serv <- services:
      if serv.blueprint_id == blueprint_id:
        result <<- serv
    <- result

func deploy(bid: string, tag: string, subnet: string) -> bool, *Error:
    sid <- Srv.create(bid)
    success, errors <- registerServiceRecord(subnet, tag, INIT_PEER_ID, [sid])
    <- success, errors


func deploy_storage(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", STORAGE, subnet)
    <- success, errors


func deploy_healthcheck_service(subnet: string) -> bool, *Error:
    -- where to get blueprint_id?
    success, errors <- deploy("", SERVICE, subnet)
    <- success, errors


func upload_air(air_path: string, ipfs_host: PeerId) -> ?CID, ?Error:
    error: ?Error
    cid: ?CID

    Console.print(["will upload", air_path, ipfs_host])

    maddr <- get_external_api_multiaddr(ipfs_host)
    if maddr.success:
        Console.print(["success", maddr.multiaddr])
        cid <- upload(maddr.multiaddr, air_path)
    else:
        Console.print(["fail", maddr.error])
        error <<- maddr.error

    <- cid, error

func create_healthcheck(subnet: ResourceId, air_path: string, ipfs_host: PeerId) -> ?CID, ?[]Error:
    errors: ?[]Error

    cid, upload_err <- upload_air(air_path, ipfs_host)

    Console.print(cid)

    if cid != nil:
        registered, err_reg <- registerServiceRecord(subnet, IPFS_HEALTHCHECK_SCRIPT, ipfs_host, ?[cid!])
        if err_reg != nil:
            errors <<- err_reg
    else:
        errors <<- ["upload_air", ipfs_host, air_path, upload_err!]

    <- cid, errors

service IOp("op"):
    identity(i: u32) -> u32

service BOp("op"):
    array_length(arr: []bool) -> u32

func create_subnet(subnet_label: string, air_path: string, ipfs_hosts: []PeerId) -> ?ResourceId, u32, []Error:
    errors: *Error
    uploaded: *bool

    subnet, errors_cre <- createResource(subnet_label)

    if subnet != nil:
        for ipfs <- ipfs_hosts par:
            cid, errors_hc <- create_healthcheck(subnet!, air_path, ipfs)
            uploaded <<- true
            if errors_hc != nil:
                for e <- errors_hc!:
                    errors <<- e

            l = Op.array_length(ipfs_hosts) --IOp.identity(ipfs_hosts.length)
            join uploaded[l]
            par Peer.timeout(PARTICLE_TTL * 8 / 10, "")

    else:
        for e <- errors_cre:
            errors <<- e

    uploaded_can = uploaded
    uploaded_len = BOp.array_length(uploaded_can) --IOp.identity(uploaded_can.length)

    <- subnet, uploaded_len, errors

-- Register deployed HealthStorage service to subnet
func register_storage(subnet: ResourceId, storage_id: string, host: PeerId) -> bool, []Error:
    registered, err_reg <- registerServiceRecord(subnet, STORAGE, host, ?[storage_id])
    <- registered, err_reg


-- Install subnet's healthcheck scripts as scheduled scripts to `target_host` peer
func install_healthcheck_scripts(scripts: []Record, target_host: PeerId) -> []string, [][]Error:
    errors: *[]Error
    installed_cids: *string
    installed_scripts: *string
    maddrs: *IpfsMultiaddrResult

    for r <- scripts:
        if r.metadata.value == IPFS_HEALTHCHECK_SCRIPT:
            cid = r.metadata.service_id!
            if contains(installed_cids, cid) == false: -- if we hadn't install this cid yet, go install it
                maddr <- get_external_api_multiaddr(r.metadata.peer_id)
                maddrs <<- maddr
                if maddr.success:
                    get <- get_from(target_host, cid, maddr.multiaddr)
                    if get.success:
                        on target_host:
                            installed_scripts <- Script.add_from_vault(get.path, ?[10])
                        installed_cids <<- cid
                    else:
                        errors <<- ?["ipfs.get", cid, get.error]
                else:
                    errors <<- ?["get_external_api_multiaddr", r.metadata.peer_id, maddr.error]

    <- installed_scripts, errors

-- It's the key owner's job to make sure that there are enough HealthStorage services
-- maybe there are NO storage services? it's all hidden inside the healthcheck script anyway

func enable_healthcheck(subnet: string, host: PeerId) -> []string, [][]Error:
    errors: *[]Error
    script_ids: *string

    records, error <- get_records(subnet, 5)

    if records != nil:
        Console.print(["NOT EMPTY"])
        -- if contains_peer_id(records!, host) == false:
        scripts: *Record
        for r <- records!:
            Console.print([r.metadata.value])
            if r.metadata.value == IPFS_HEALTHCHECK_SCRIPT:
                scripts <<- r
        NConsole.print(ROp.array_length(scripts))
        -- scripts <- find_records(records!, IPFS_HEALTHCHECK_SCRIPT)
        installed_scripts, install_errs <- install_healthcheck_scripts(scripts, host)
        for err <- install_errs:
            errors <<- err
        for s <- installed_scripts:
            script_ids <<- s
    else:
        Console.print(["EMPTYY"])
        errors <<- error

    <- script_ids, errors

func join_subnet(subnet: ResourceId, host: PeerId, service_id: string) -> bool, []string, []Error:
    errors: *[]Error
    script_ids: *string

    -- TODO: check that service wasn't registered yet?
    registered, error_reg <- registerServiceRecord(subnet, SERVICE, host, ?[service_id])
    if registered:
        scripts, errs_hc <- enable_healthcheck(subnet, host)
        for e <- errs_hc:
            errors <<- e
        for s <- scripts:
            script_ids <<- s

    <- registered, script_ids, error_reg

func get_health(subnet: ResourceId) -> []string:
    statuses: *string

    records, error_resolve <- get_records(subnet, 3) -- '3' acks

    if records != nil:
        services: *Record
        for r <- records!:
            if r.metadata.value == SERVICE:
                services <<- r

        storages: *Record
        for r <- records!:
            if r.metadata.value == STORAGE:
                storages <<- r

        -- storages <- find_records(records!, STORAGE)
        -- services <- find_records(records!, SERVICE)
        for storage <- storages par:
            for srv <- services par:
                on storage.metadata.peer_id via storage.metadata.relay_id:
                    HealthCheckStorage storage.metadata.service_id!
                    status <- HealthCheckStorage.get_status(srv.metadata.service_id!)
                    if status == nil:
                        statuses <<- "no status :("
                    else:
                        statuses <<- status!.status

        join statuses[ROp.array_length(services) - 1]
        par Peer.timeout(PARTICLE_TTL * 8 / 10, "")

    <- statuses

        -- "peer_id": "12D3KooWDcpWuyrMTDinqNgmXAuRdfd2mTdY9VoXZSAet2pDzh6r",
        -- "relay_id": [],
        -- "service_id": [
        --   "505f4b4f-eb41-4b40-a668-e04ce4400203"
        -- ],
        -- "solution": [],
        -- "timestamp_issued": 1666101386,
        -- "value": "role=healthcheckstorage"



func list_records(subnet: ResourceId) -> [][]string, []Error:
    minified_records: *[]string

    records, error_resolve <- get_records(subnet, 3) -- '3' acks
    if records != nil:
        for r <- records!:
            if r.metadata.service_id != nil:
                minified_records <<- [r.metadata.peer_id, r.metadata.value, r.metadata.service_id!]
            else:
                minified_records <<- [r.metadata.peer_id, r.metadata.value]

    <- minified_records, error_resolve

func list_scheduled(subnet: ResourceId) -> [][]ScriptInfo, []Error:
    scripts: *[]ScriptInfo

    records, error_resolve <- get_records(subnet, 5) -- '3' acks

    if records != nil:
        services: *Record
        for r <- records!:
            if r.metadata.value == SERVICE:
                services <<- r

        -- for r <- records!:
        --     Console.print(["wtf"])
        --     RConsole.print(r)

        -- services <- find_records(records!, SERVICE)
        for s <- services:
            if s.metadata.value == SERVICE:
                -- Console.print([s.metadata.peer_id, s.metadata.relay_id!])
                -- RConsole.print(s)
                on s.metadata.peer_id via s.metadata.relay_id:
                    scripts <- Script.list()

    <- scripts, error_resolve
